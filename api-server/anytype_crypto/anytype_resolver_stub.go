// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package anytype_crypto

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// AnytypeResolverMetaData contains all meta data concerning the AnytypeResolver contract.
var AnytypeResolverMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractENS\",\"name\":\"_ens\",\"type\":\"address\"},{\"internalType\":\"contractINameWrapper\",\"name\":\"wrapperAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trustedETHController1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trustedETHController2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trustedReverseRegistrar\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"ContenthashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"record\",\"type\":\"bytes\"}],\"name\":\"DNSRecordChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"}],\"name\":\"DNSRecordDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lastzonehash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"zonehash\",\"type\":\"bytes\"}],\"name\":\"DNSZonehashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"name\":\"PubkeyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"spaceId\",\"type\":\"bytes\"}],\"name\":\"SpaceIDChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"indexedKey\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"TextChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newVersion\",\"type\":\"uint64\"}],\"name\":\"VersionChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"clearRecords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"contenthash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"}],\"name\":\"dnsRecord\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"hasDNSRecords\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"isApprovedFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodehash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicallWithNodeCheck\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"pubkey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"recordVersions\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"setContenthash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setDNSRecords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"name\":\"setPubkey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"spaceid\",\"type\":\"bytes\"}],\"name\":\"setSpaceId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"setZonehash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"spaceId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"text\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"zonehash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6101206040523480156200001257600080fd5b506040516200290438038062002904833981016040819052620000359162000181565b6040516302571be360e01b81527f91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e26004820152859033906000906001600160a01b038416906302571be390602401602060405180830381865afa158015620000a1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000c7919062000201565b604051630f41a04d60e11b81526001600160a01b03848116600483015291925090821690631e83409a906024016020604051808303816000875af115801562000114573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200013a919062000228565b5050506001600160a01b039586166080525092841660a05290831660c052821660e052166101005262000242565b6001600160a01b03811681146200017e57600080fd5b50565b600080600080600060a086880312156200019a57600080fd5b8551620001a78162000168565b6020870151909550620001ba8162000168565b6040870151909450620001cd8162000168565b6060870151909350620001e08162000168565b6080870151909250620001f38162000168565b809150509295509295909350565b6000602082840312156200021457600080fd5b8151620002218162000168565b9392505050565b6000602082840312156200023b57600080fd5b5051919050565b60805160a05160c05160e051610100516126766200028e60003960006110ad0152600061107a0152600061104801526000818161118501526111eb0152600061110e01526126766000f3fe608060405234801561001057600080fd5b50600436106101985760003560e01c8063a22cb465116100e3578063c86902331161008c578063e32954eb11610066578063e32954eb1461043d578063e985e9c514610450578063f49c1a7b1461048c57600080fd5b8063c86902331461038e578063ce3decdc146103e7578063d700ff33146103fa57600080fd5b8063a9784b3e116100bd578063a9784b3e14610317578063ac9650d81461035b578063bc1c58d11461037b57600080fd5b8063a22cb465146102de578063a4b91a01146102f1578063a8fa56821461030457600080fd5b80634cbf6ba411610145578063691f34311161011f578063691f3431146102a557806377372213146102b85780639d30c3b0146102cb57600080fd5b80634cbf6ba41461022657806359d1d43c146102725780635c98042b1461029257600080fd5b806329cd62ea1161017657806329cd62ea146101ed578063304e6ade146102005780633603d7581461021357600080fd5b806301ffc9a71461019d5780630af179d7146101c557806310f13a8c146101da575b600080fd5b6101b06101ab366004611cff565b61049f565b60405190151581526020015b60405180910390f35b6101d86101d3366004611d72565b6104b0565b005b6101d86101e8366004611dbe565b6106ba565b6101d86101fb366004611e38565b610787565b6101d861020e366004611d72565b610822565b6101d8610221366004611e64565b61089e565b6101b0610234366004611e7d565b6000828152602081815260408083205467ffffffffffffffff1683526004825280832094835293815283822092825291909152205461ffff16151590565b610285610280366004611d72565b610941565b6040516101bc9190611eef565b6102856102a0366004611e64565b610a21565b6102856102b3366004611e64565b610ae0565b6101d86102c6366004611d72565b610b1a565b6102856102d9366004611e64565b610b96565b6101d86102ec366004611f2c565b610bd0565b6101d86102ff366004611f61565b610cbf565b610285610312366004611f9f565b610d8c565b6101b0610325366004611fdf565b6001600160a01b039283166000908152600a60209081526040808320948352938152838220929094168152925290205460ff1690565b61036e61036936600461205b565b610dda565b6040516101bc919061209d565b610285610389366004611e64565b610def565b6103d261039c366004611e64565b6000818152602081815260408083205467ffffffffffffffff168352600682528083209383529290522080546001909101549091565b604080519283526020830191909152016101bc565b6101d86103f5366004611d72565b610e29565b610424610408366004611e64565b60006020819052908152604090205467ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020016101bc565b61036e61044b3660046120ff565b610f6c565b6101b061045e36600461213e565b6001600160a01b03918216600090815260096020908152604080832093909416825291909152205460ff1690565b6101d861049a366004611d72565b610f81565b60006104aa82610ffd565b92915050565b826104ba8161103b565b6104c357600080fd5b600084815260208181526040808320548151601f870184900484028101840190925285825283926060928392859267ffffffffffffffff9091169183916105299183918d908d908190840183828082843760009201919091525092939250506112d59050565b90505b80515160208201511015610653578661ffff16600003610591578060400151965061055681611336565b9450846040516020016105699190612177565b60405160208183030381529060405280519060200120925061058a81611357565b9350610645565b600061059c82611336565b9050816040015161ffff168861ffff161415806105c057506105be8682611373565b155b156106435761061c8c878a8e8e8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250505060208801518d91506106139082906121a9565b8b51158a611391565b81604001519750816020015196508095508580519060200120935061064082611357565b94505b505b61064e816115fe565b61052c565b508351156106ae576106ae8a85888c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c92506106a591508290508f6121a9565b89511588611391565b50505050505050505050565b846106c48161103b565b6106cd57600080fd5b6000868152602081815260408083205467ffffffffffffffff168352600782528083208984529091529081902090518491849161070d90899089906121bc565b9081526020016040518091039020918261072892919061226b565b5084846040516107399291906121bc565b6040518091039020867f448bc014f1536726cf8d54ff3d6481ed3cbc683c2591ca204274009afa09b1a1878787876040516107779493929190612355565b60405180910390a3505050505050565b826107918161103b565b61079a57600080fd5b604080518082018252848152602080820185815260008881528083528481205467ffffffffffffffff1681526006835284812089825283528490209251835551600190920191909155815185815290810184905285917f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e4691015b60405180910390a250505050565b8261082c8161103b565b61083557600080fd5b6000848152602081815260408083205467ffffffffffffffff16835260018252808320878452909152902061086b83858361226b565b50837fe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d75788484604051610814929190612387565b806108a88161103b565b6108b157600080fd5b6000828152602081905260408120805467ffffffffffffffff16916108d58361239b565b82546101009290920a67ffffffffffffffff818102199093169183160217909155600084815260208181526040918290205491519190921681528492507fc6621ccb8f3f5a04bb6502154b2caf6adf5983fe76dfef1cfc9c42e3579db444910160405180910390a25050565b6000838152602081815260408083205467ffffffffffffffff168352600782528083208684529091529081902090516060919061098190859085906121bc565b9081526020016040518091039020805461099a906121e2565b80601f01602080910402602001604051908101604052809291908181526020018280546109c6906121e2565b8015610a135780601f106109e857610100808354040283529160200191610a13565b820191906000526020600020905b8154815290600101906020018083116109f657829003601f168201915b505050505090509392505050565b6000818152602081815260408083205467ffffffffffffffff168352600282528083208484529091529020805460609190610a5b906121e2565b80601f0160208091040260200160405190810160405280929190818152602001828054610a87906121e2565b8015610ad45780601f10610aa957610100808354040283529160200191610ad4565b820191906000526020600020905b815481529060010190602001808311610ab757829003601f168201915b50505050509050919050565b6000818152602081815260408083205467ffffffffffffffff168352600582528083208484529091529020805460609190610a5b906121e2565b82610b248161103b565b610b2d57600080fd5b6000848152602081815260408083205467ffffffffffffffff168352600582528083208784529091529020610b6383858361226b565b50837fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f78484604051610814929190612387565b6000818152602081815260408083205467ffffffffffffffff168352600882528083208484529091529020805460609190610a5b906121e2565b6001600160a01b0382163303610c535760405162461bcd60e51b815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c2073746174757360448201527f20666f722073656c66000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b3360008181526009602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b6001600160a01b0382163303610d175760405162461bcd60e51b815260206004820181905260248201527f53657474696e672064656c65676174652073746174757320666f722073656c666044820152606401610c4a565b336000818152600a6020908152604080832087845282528083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519384529286917ff0ddb3b04746704017f9aa8bd728fcc2c1d11675041205350018915f5e4750a0910160405180910390a4505050565b6000838152602081815260408083205467ffffffffffffffff168352600382528083208684528252808320858452825280832061ffff85168452909152902080546060919061099a906121e2565b6060610de8600084846116e6565b9392505050565b6000818152602081815260408083205467ffffffffffffffff168352600182528083208484529091529020805460609190610a5b906121e2565b82610e338161103b565b610e3c57600080fd5b6000848152602081815260408083205467ffffffffffffffff168084526002835281842088855290925282208054919291610e76906121e2565b80601f0160208091040260200160405190810160405280929190818152602001828054610ea2906121e2565b8015610eef5780601f10610ec457610100808354040283529160200191610eef565b820191906000526020600020905b815481529060010190602001808311610ed257829003601f168201915b5050505067ffffffffffffffff841660009081526002602090815260408083208b84529091529020919250610f27905085878361226b565b50857f8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f85828787604051610f5c939291906123c2565b60405180910390a2505050505050565b6060610f798484846116e6565b949350505050565b82610f8b8161103b565b610f9457600080fd5b6000848152602081815260408083205467ffffffffffffffff168352600882528083208784529091529020610fca83858361226b565b50837fd0f766f33d7be4ce1dbcfb11f7fbe0cb18b74331b99a4a7c1565c95471346e388484604051610814929190612387565b60006001600160e01b031982167f9d30c3b00000000000000000000000000000000000000000000000000000000014806104aa57506104aa826118bf565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016148061109c5750336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016145b806110cf5750336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016145b156110dc57506001919050565b6040517f02571be3000000000000000000000000000000000000000000000000000000008152600481018390526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906302571be390602401602060405180830381865afa15801561115d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061118191906123f2565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b031603611261576040517f6352211e000000000000000000000000000000000000000000000000000000008152600481018490527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa15801561123a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061125e91906123f2565b90505b6001600160a01b03811633148061129b57506001600160a01b038116600090815260096020908152604080832033845290915290205460ff165b80610de857506001600160a01b0381166000908152600a60209081526040808320868452825280832033845290915290205460ff16610de8565b6113236040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b82815260c081018290526104aa816115fe565b602081015181516060916104aa9161134e90826118fd565b84519190611957565b60a081015160c08201516060916104aa9161134e9082906121a9565b600081518351148015610de85750610de883600084600087516119d9565b8651602088012060006113a5878787611957565b905083156114cf5767ffffffffffffffff831660009081526003602090815260408083208d84528252808320858452825280832061ffff8c168452909152902080546113f0906121e2565b15905061144f5767ffffffffffffffff831660009081526004602090815260408083208d845282528083208584529091528120805461ffff16916114338361240f565b91906101000a81548161ffff021916908361ffff160217905550505b67ffffffffffffffff831660009081526003602090815260408083208d84528252808320858452825280832061ffff8c168452909152812061149091611ca9565b897f03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a12078a8a6040516114c292919061242d565b60405180910390a26106ae565b67ffffffffffffffff831660009081526003602090815260408083208d84528252808320858452825280832061ffff8c16845290915290208054611512906121e2565b90506000036115735767ffffffffffffffff831660009081526004602090815260408083208d845282528083208584529091528120805461ffff169161155783612453565b91906101000a81548161ffff021916908361ffff160217905550505b67ffffffffffffffff831660009081526003602090815260408083208d84528252808320858452825280832061ffff8c16845290915290206115b5828261246a565b50897f52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b8a8a846040516115ea9392919061252a565b60405180910390a250505050505050505050565b60c081015160208201819052815151116116155750565b6000611629826000015183602001516118fd565b82602001516116389190612559565b825190915061164790826119fc565b61ffff16604083015261165b600282612559565b825190915061166a90826119fc565b61ffff16606083015261167e600282612559565b825190915061168d9082611a24565b63ffffffff1660808301526116a3600482612559565b82519091506000906116b590836119fc565b61ffff1690506116c6600283612559565b60a0840181905291506116d98183612559565b60c0909301929092525050565b60608167ffffffffffffffff811115611701576117016121cc565b60405190808252806020026020018201604052801561173457816020015b606081526020019060019003908161171f5790505b50905060005b828110156118b75784156117ff57600084848381811061175c5761175c61256c565b905060200281019061176e9190612582565b61177d916024916004916125c9565b611786916125f3565b90508581146117fd5760405162461bcd60e51b815260206004820152603460248201527f6d756c746963616c6c3a20416c6c207265636f726473206d757374206861766560448201527f2061206d61746368696e67206e616d65686173680000000000000000000000006064820152608401610c4a565b505b600080308686858181106118155761181561256c565b90506020028101906118279190612582565b6040516118359291906121bc565b600060405180830381855af49150503d8060008114611870576040519150601f19603f3d011682016040523d82523d6000602084013e611875565b606091505b50915091508161188457600080fd5b808484815181106118975761189761256c565b6020026020010181905250505080806118af90612611565b91505061173a565b509392505050565b60006001600160e01b031982167f59d1d43c0000000000000000000000000000000000000000000000000000000014806104aa57506104aa82611a4e565b6000815b835181106119115761191161262a565b600061191d8583611a8c565b60ff16905061192d816001612559565b6119379083612559565b915080600003611947575061194d565b50611901565b610f7983826121a9565b82516060906119668385612559565b111561197157600080fd5b60008267ffffffffffffffff81111561198c5761198c6121cc565b6040519080825280601f01601f1916602001820160405280156119b6576020820181803683370190505b509050602080820190868601016119ce828287611ab0565b509095945050505050565b60006119e6848484611b06565b6119f1878785611b06565b149695505050505050565b8151600090611a0c836002612559565b1115611a1757600080fd5b50016002015161ffff1690565b8151600090611a34836004612559565b1115611a3f57600080fd5b50016004015163ffffffff1690565b60006001600160e01b031982167fc86902330000000000000000000000000000000000000000000000000000000014806104aa57506104aa82611b2a565b6000828281518110611aa057611aa061256c565b016020015160f81c905092915050565b60208110611ae85781518352611ac7602084612559565b9250611ad4602083612559565b9150611ae16020826121a9565b9050611ab0565b905182516020929092036101000a6000190180199091169116179052565b8251600090611b158385612559565b1115611b2057600080fd5b5091016020012090565b60006001600160e01b031982167f691f34310000000000000000000000000000000000000000000000000000000014806104aa57506104aa8260006001600160e01b031982167fa8fa5682000000000000000000000000000000000000000000000000000000001480611bc657506001600160e01b031982167f5c98042b00000000000000000000000000000000000000000000000000000000145b806104aa57506104aa8260006001600160e01b031982167fbc1c58d10000000000000000000000000000000000000000000000000000000014806104aa57506104aa8260006001600160e01b031982167fd700ff330000000000000000000000000000000000000000000000000000000014806104aa57506104aa8260006001600160e01b031982167f4fbf04330000000000000000000000000000000000000000000000000000000014806104aa57507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b03198316146104aa565b508054611cb5906121e2565b6000825580601f10611cc5575050565b601f016020900490600052602060002090810190611ce39190611ce6565b50565b5b80821115611cfb5760008155600101611ce7565b5090565b600060208284031215611d1157600080fd5b81356001600160e01b031981168114610de857600080fd5b60008083601f840112611d3b57600080fd5b50813567ffffffffffffffff811115611d5357600080fd5b602083019150836020828501011115611d6b57600080fd5b9250929050565b600080600060408486031215611d8757600080fd5b83359250602084013567ffffffffffffffff811115611da557600080fd5b611db186828701611d29565b9497909650939450505050565b600080600080600060608688031215611dd657600080fd5b85359450602086013567ffffffffffffffff80821115611df557600080fd5b611e0189838a01611d29565b90965094506040880135915080821115611e1a57600080fd5b50611e2788828901611d29565b969995985093965092949392505050565b600080600060608486031215611e4d57600080fd5b505081359360208301359350604090920135919050565b600060208284031215611e7657600080fd5b5035919050565b60008060408385031215611e9057600080fd5b50508035926020909101359150565b60005b83811015611eba578181015183820152602001611ea2565b50506000910152565b60008151808452611edb816020860160208601611e9f565b601f01601f19169290920160200192915050565b602081526000610de86020830184611ec3565b6001600160a01b0381168114611ce357600080fd5b80358015158114611f2757600080fd5b919050565b60008060408385031215611f3f57600080fd5b8235611f4a81611f02565b9150611f5860208401611f17565b90509250929050565b600080600060608486031215611f7657600080fd5b833592506020840135611f8881611f02565b9150611f9660408501611f17565b90509250925092565b600080600060608486031215611fb457600080fd5b8335925060208401359150604084013561ffff81168114611fd457600080fd5b809150509250925092565b600080600060608486031215611ff457600080fd5b8335611fff81611f02565b9250602084013591506040840135611fd481611f02565b60008083601f84011261202857600080fd5b50813567ffffffffffffffff81111561204057600080fd5b6020830191508360208260051b8501011115611d6b57600080fd5b6000806020838503121561206e57600080fd5b823567ffffffffffffffff81111561208557600080fd5b61209185828601612016565b90969095509350505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156120f257603f198886030184526120e0858351611ec3565b945092850192908501906001016120c4565b5092979650505050505050565b60008060006040848603121561211457600080fd5b83359250602084013567ffffffffffffffff81111561213257600080fd5b611db186828701612016565b6000806040838503121561215157600080fd5b823561215c81611f02565b9150602083013561216c81611f02565b809150509250929050565b60008251612189818460208701611e9f565b9190910192915050565b634e487b7160e01b600052601160045260246000fd5b818103818111156104aa576104aa612193565b8183823760009101908152919050565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806121f657607f821691505b60208210810361221657634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561226657600081815260208120601f850160051c810160208610156122435750805b601f850160051c820191505b818110156122625782815560010161224f565b5050505b505050565b67ffffffffffffffff831115612283576122836121cc565b6122978361229183546121e2565b8361221c565b6000601f8411600181146122cb57600085156122b35750838201355b600019600387901b1c1916600186901b178355612325565b600083815260209020601f19861690835b828110156122fc57868501358255602094850194600190920191016122dc565b50868210156123195760001960f88860031b161c19848701351681555b505060018560011b0183555b5050505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60408152600061236960408301868861232c565b828103602084015261237c81858761232c565b979650505050505050565b602081526000610f7960208301848661232c565b600067ffffffffffffffff8083168181036123b8576123b8612193565b6001019392505050565b6040815260006123d56040830186611ec3565b82810360208401526123e881858761232c565b9695505050505050565b60006020828403121561240457600080fd5b8151610de881611f02565b600061ffff82168061242357612423612193565b6000190192915050565b6040815260006124406040830185611ec3565b905061ffff831660208301529392505050565b600061ffff8083168181036123b8576123b8612193565b815167ffffffffffffffff811115612484576124846121cc565b6124988161249284546121e2565b8461221c565b602080601f8311600181146124cd57600084156124b55750858301515b600019600386901b1c1916600185901b178555612262565b600085815260208120601f198616915b828110156124fc578886015182559484019460019091019084016124dd565b508582101561251a5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60608152600061253d6060830186611ec3565b61ffff8516602084015282810360408401526123e88185611ec3565b808201808211156104aa576104aa612193565b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261259957600080fd5b83018035915067ffffffffffffffff8211156125b457600080fd5b602001915036819003821315611d6b57600080fd5b600080858511156125d957600080fd5b838611156125e657600080fd5b5050820193919092039150565b803560208310156104aa57600019602084900360031b1b1692915050565b60006001820161262357612623612193565b5060010190565b634e487b7160e01b600052600160045260246000fdfea2646970667358221220604df88f1b8635d04501b02736b910e5ec4f28e97864679c64d649b7b0c4840264736f6c63430008110033",
}

// AnytypeResolverABI is the input ABI used to generate the binding from.
// Deprecated: Use AnytypeResolverMetaData.ABI instead.
var AnytypeResolverABI = AnytypeResolverMetaData.ABI

// AnytypeResolverBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AnytypeResolverMetaData.Bin instead.
var AnytypeResolverBin = AnytypeResolverMetaData.Bin

// DeployAnytypeResolver deploys a new Ethereum contract, binding an instance of AnytypeResolver to it.
func DeployAnytypeResolver(auth *bind.TransactOpts, backend bind.ContractBackend, _ens common.Address, wrapperAddress common.Address, _trustedETHController1 common.Address, _trustedETHController2 common.Address, _trustedReverseRegistrar common.Address) (common.Address, *types.Transaction, *AnytypeResolver, error) {
	parsed, err := AnytypeResolverMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AnytypeResolverBin), backend, _ens, wrapperAddress, _trustedETHController1, _trustedETHController2, _trustedReverseRegistrar)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AnytypeResolver{AnytypeResolverCaller: AnytypeResolverCaller{contract: contract}, AnytypeResolverTransactor: AnytypeResolverTransactor{contract: contract}, AnytypeResolverFilterer: AnytypeResolverFilterer{contract: contract}}, nil
}

// AnytypeResolver is an auto generated Go binding around an Ethereum contract.
type AnytypeResolver struct {
	AnytypeResolverCaller     // Read-only binding to the contract
	AnytypeResolverTransactor // Write-only binding to the contract
	AnytypeResolverFilterer   // Log filterer for contract events
}

// AnytypeResolverCaller is an auto generated read-only Go binding around an Ethereum contract.
type AnytypeResolverCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AnytypeResolverTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AnytypeResolverTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AnytypeResolverFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AnytypeResolverFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AnytypeResolverSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AnytypeResolverSession struct {
	Contract     *AnytypeResolver  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AnytypeResolverCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AnytypeResolverCallerSession struct {
	Contract *AnytypeResolverCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// AnytypeResolverTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AnytypeResolverTransactorSession struct {
	Contract     *AnytypeResolverTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// AnytypeResolverRaw is an auto generated low-level Go binding around an Ethereum contract.
type AnytypeResolverRaw struct {
	Contract *AnytypeResolver // Generic contract binding to access the raw methods on
}

// AnytypeResolverCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AnytypeResolverCallerRaw struct {
	Contract *AnytypeResolverCaller // Generic read-only contract binding to access the raw methods on
}

// AnytypeResolverTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AnytypeResolverTransactorRaw struct {
	Contract *AnytypeResolverTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAnytypeResolver creates a new instance of AnytypeResolver, bound to a specific deployed contract.
func NewAnytypeResolver(address common.Address, backend bind.ContractBackend) (*AnytypeResolver, error) {
	contract, err := bindAnytypeResolver(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolver{AnytypeResolverCaller: AnytypeResolverCaller{contract: contract}, AnytypeResolverTransactor: AnytypeResolverTransactor{contract: contract}, AnytypeResolverFilterer: AnytypeResolverFilterer{contract: contract}}, nil
}

// NewAnytypeResolverCaller creates a new read-only instance of AnytypeResolver, bound to a specific deployed contract.
func NewAnytypeResolverCaller(address common.Address, caller bind.ContractCaller) (*AnytypeResolverCaller, error) {
	contract, err := bindAnytypeResolver(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverCaller{contract: contract}, nil
}

// NewAnytypeResolverTransactor creates a new write-only instance of AnytypeResolver, bound to a specific deployed contract.
func NewAnytypeResolverTransactor(address common.Address, transactor bind.ContractTransactor) (*AnytypeResolverTransactor, error) {
	contract, err := bindAnytypeResolver(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverTransactor{contract: contract}, nil
}

// NewAnytypeResolverFilterer creates a new log filterer instance of AnytypeResolver, bound to a specific deployed contract.
func NewAnytypeResolverFilterer(address common.Address, filterer bind.ContractFilterer) (*AnytypeResolverFilterer, error) {
	contract, err := bindAnytypeResolver(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverFilterer{contract: contract}, nil
}

// bindAnytypeResolver binds a generic wrapper to an already deployed contract.
func bindAnytypeResolver(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(AnytypeResolverABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AnytypeResolver *AnytypeResolverRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AnytypeResolver.Contract.AnytypeResolverCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AnytypeResolver *AnytypeResolverRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.AnytypeResolverTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AnytypeResolver *AnytypeResolverRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.AnytypeResolverTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AnytypeResolver *AnytypeResolverCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AnytypeResolver.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AnytypeResolver *AnytypeResolverTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AnytypeResolver *AnytypeResolverTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.contract.Transact(opts, method, params...)
}

// Contenthash is a free data retrieval call binding the contract method 0xbc1c58d1.
//
// Solidity: function contenthash(bytes32 node) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverCaller) Contenthash(opts *bind.CallOpts, node [32]byte) ([]byte, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "contenthash", node)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// Contenthash is a free data retrieval call binding the contract method 0xbc1c58d1.
//
// Solidity: function contenthash(bytes32 node) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverSession) Contenthash(node [32]byte) ([]byte, error) {
	return _AnytypeResolver.Contract.Contenthash(&_AnytypeResolver.CallOpts, node)
}

// Contenthash is a free data retrieval call binding the contract method 0xbc1c58d1.
//
// Solidity: function contenthash(bytes32 node) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverCallerSession) Contenthash(node [32]byte) ([]byte, error) {
	return _AnytypeResolver.Contract.Contenthash(&_AnytypeResolver.CallOpts, node)
}

// DnsRecord is a free data retrieval call binding the contract method 0xa8fa5682.
//
// Solidity: function dnsRecord(bytes32 node, bytes32 name, uint16 resource) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverCaller) DnsRecord(opts *bind.CallOpts, node [32]byte, name [32]byte, resource uint16) ([]byte, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "dnsRecord", node, name, resource)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// DnsRecord is a free data retrieval call binding the contract method 0xa8fa5682.
//
// Solidity: function dnsRecord(bytes32 node, bytes32 name, uint16 resource) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverSession) DnsRecord(node [32]byte, name [32]byte, resource uint16) ([]byte, error) {
	return _AnytypeResolver.Contract.DnsRecord(&_AnytypeResolver.CallOpts, node, name, resource)
}

// DnsRecord is a free data retrieval call binding the contract method 0xa8fa5682.
//
// Solidity: function dnsRecord(bytes32 node, bytes32 name, uint16 resource) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverCallerSession) DnsRecord(node [32]byte, name [32]byte, resource uint16) ([]byte, error) {
	return _AnytypeResolver.Contract.DnsRecord(&_AnytypeResolver.CallOpts, node, name, resource)
}

// HasDNSRecords is a free data retrieval call binding the contract method 0x4cbf6ba4.
//
// Solidity: function hasDNSRecords(bytes32 node, bytes32 name) view returns(bool)
func (_AnytypeResolver *AnytypeResolverCaller) HasDNSRecords(opts *bind.CallOpts, node [32]byte, name [32]byte) (bool, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "hasDNSRecords", node, name)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasDNSRecords is a free data retrieval call binding the contract method 0x4cbf6ba4.
//
// Solidity: function hasDNSRecords(bytes32 node, bytes32 name) view returns(bool)
func (_AnytypeResolver *AnytypeResolverSession) HasDNSRecords(node [32]byte, name [32]byte) (bool, error) {
	return _AnytypeResolver.Contract.HasDNSRecords(&_AnytypeResolver.CallOpts, node, name)
}

// HasDNSRecords is a free data retrieval call binding the contract method 0x4cbf6ba4.
//
// Solidity: function hasDNSRecords(bytes32 node, bytes32 name) view returns(bool)
func (_AnytypeResolver *AnytypeResolverCallerSession) HasDNSRecords(node [32]byte, name [32]byte) (bool, error) {
	return _AnytypeResolver.Contract.HasDNSRecords(&_AnytypeResolver.CallOpts, node, name)
}

// IsApprovedFor is a free data retrieval call binding the contract method 0xa9784b3e.
//
// Solidity: function isApprovedFor(address owner, bytes32 node, address delegate) view returns(bool)
func (_AnytypeResolver *AnytypeResolverCaller) IsApprovedFor(opts *bind.CallOpts, owner common.Address, node [32]byte, delegate common.Address) (bool, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "isApprovedFor", owner, node, delegate)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedFor is a free data retrieval call binding the contract method 0xa9784b3e.
//
// Solidity: function isApprovedFor(address owner, bytes32 node, address delegate) view returns(bool)
func (_AnytypeResolver *AnytypeResolverSession) IsApprovedFor(owner common.Address, node [32]byte, delegate common.Address) (bool, error) {
	return _AnytypeResolver.Contract.IsApprovedFor(&_AnytypeResolver.CallOpts, owner, node, delegate)
}

// IsApprovedFor is a free data retrieval call binding the contract method 0xa9784b3e.
//
// Solidity: function isApprovedFor(address owner, bytes32 node, address delegate) view returns(bool)
func (_AnytypeResolver *AnytypeResolverCallerSession) IsApprovedFor(owner common.Address, node [32]byte, delegate common.Address) (bool, error) {
	return _AnytypeResolver.Contract.IsApprovedFor(&_AnytypeResolver.CallOpts, owner, node, delegate)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_AnytypeResolver *AnytypeResolverCaller) IsApprovedForAll(opts *bind.CallOpts, account common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "isApprovedForAll", account, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_AnytypeResolver *AnytypeResolverSession) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _AnytypeResolver.Contract.IsApprovedForAll(&_AnytypeResolver.CallOpts, account, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_AnytypeResolver *AnytypeResolverCallerSession) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _AnytypeResolver.Contract.IsApprovedForAll(&_AnytypeResolver.CallOpts, account, operator)
}

// Name is a free data retrieval call binding the contract method 0x691f3431.
//
// Solidity: function name(bytes32 node) view returns(string)
func (_AnytypeResolver *AnytypeResolverCaller) Name(opts *bind.CallOpts, node [32]byte) (string, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "name", node)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x691f3431.
//
// Solidity: function name(bytes32 node) view returns(string)
func (_AnytypeResolver *AnytypeResolverSession) Name(node [32]byte) (string, error) {
	return _AnytypeResolver.Contract.Name(&_AnytypeResolver.CallOpts, node)
}

// Name is a free data retrieval call binding the contract method 0x691f3431.
//
// Solidity: function name(bytes32 node) view returns(string)
func (_AnytypeResolver *AnytypeResolverCallerSession) Name(node [32]byte) (string, error) {
	return _AnytypeResolver.Contract.Name(&_AnytypeResolver.CallOpts, node)
}

// Pubkey is a free data retrieval call binding the contract method 0xc8690233.
//
// Solidity: function pubkey(bytes32 node) view returns(bytes32 x, bytes32 y)
func (_AnytypeResolver *AnytypeResolverCaller) Pubkey(opts *bind.CallOpts, node [32]byte) (struct {
	X [32]byte
	Y [32]byte
}, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "pubkey", node)

	outstruct := new(struct {
		X [32]byte
		Y [32]byte
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.X = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Y = *abi.ConvertType(out[1], new([32]byte)).(*[32]byte)

	return *outstruct, err

}

// Pubkey is a free data retrieval call binding the contract method 0xc8690233.
//
// Solidity: function pubkey(bytes32 node) view returns(bytes32 x, bytes32 y)
func (_AnytypeResolver *AnytypeResolverSession) Pubkey(node [32]byte) (struct {
	X [32]byte
	Y [32]byte
}, error) {
	return _AnytypeResolver.Contract.Pubkey(&_AnytypeResolver.CallOpts, node)
}

// Pubkey is a free data retrieval call binding the contract method 0xc8690233.
//
// Solidity: function pubkey(bytes32 node) view returns(bytes32 x, bytes32 y)
func (_AnytypeResolver *AnytypeResolverCallerSession) Pubkey(node [32]byte) (struct {
	X [32]byte
	Y [32]byte
}, error) {
	return _AnytypeResolver.Contract.Pubkey(&_AnytypeResolver.CallOpts, node)
}

// RecordVersions is a free data retrieval call binding the contract method 0xd700ff33.
//
// Solidity: function recordVersions(bytes32 ) view returns(uint64)
func (_AnytypeResolver *AnytypeResolverCaller) RecordVersions(opts *bind.CallOpts, arg0 [32]byte) (uint64, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "recordVersions", arg0)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// RecordVersions is a free data retrieval call binding the contract method 0xd700ff33.
//
// Solidity: function recordVersions(bytes32 ) view returns(uint64)
func (_AnytypeResolver *AnytypeResolverSession) RecordVersions(arg0 [32]byte) (uint64, error) {
	return _AnytypeResolver.Contract.RecordVersions(&_AnytypeResolver.CallOpts, arg0)
}

// RecordVersions is a free data retrieval call binding the contract method 0xd700ff33.
//
// Solidity: function recordVersions(bytes32 ) view returns(uint64)
func (_AnytypeResolver *AnytypeResolverCallerSession) RecordVersions(arg0 [32]byte) (uint64, error) {
	return _AnytypeResolver.Contract.RecordVersions(&_AnytypeResolver.CallOpts, arg0)
}

// SpaceId is a free data retrieval call binding the contract method 0x9d30c3b0.
//
// Solidity: function spaceId(bytes32 node) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverCaller) SpaceId(opts *bind.CallOpts, node [32]byte) ([]byte, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "spaceId", node)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// SpaceId is a free data retrieval call binding the contract method 0x9d30c3b0.
//
// Solidity: function spaceId(bytes32 node) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverSession) SpaceId(node [32]byte) ([]byte, error) {
	return _AnytypeResolver.Contract.SpaceId(&_AnytypeResolver.CallOpts, node)
}

// SpaceId is a free data retrieval call binding the contract method 0x9d30c3b0.
//
// Solidity: function spaceId(bytes32 node) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverCallerSession) SpaceId(node [32]byte) ([]byte, error) {
	return _AnytypeResolver.Contract.SpaceId(&_AnytypeResolver.CallOpts, node)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceID) view returns(bool)
func (_AnytypeResolver *AnytypeResolverCaller) SupportsInterface(opts *bind.CallOpts, interfaceID [4]byte) (bool, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "supportsInterface", interfaceID)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceID) view returns(bool)
func (_AnytypeResolver *AnytypeResolverSession) SupportsInterface(interfaceID [4]byte) (bool, error) {
	return _AnytypeResolver.Contract.SupportsInterface(&_AnytypeResolver.CallOpts, interfaceID)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceID) view returns(bool)
func (_AnytypeResolver *AnytypeResolverCallerSession) SupportsInterface(interfaceID [4]byte) (bool, error) {
	return _AnytypeResolver.Contract.SupportsInterface(&_AnytypeResolver.CallOpts, interfaceID)
}

// Text is a free data retrieval call binding the contract method 0x59d1d43c.
//
// Solidity: function text(bytes32 node, string key) view returns(string)
func (_AnytypeResolver *AnytypeResolverCaller) Text(opts *bind.CallOpts, node [32]byte, key string) (string, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "text", node, key)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Text is a free data retrieval call binding the contract method 0x59d1d43c.
//
// Solidity: function text(bytes32 node, string key) view returns(string)
func (_AnytypeResolver *AnytypeResolverSession) Text(node [32]byte, key string) (string, error) {
	return _AnytypeResolver.Contract.Text(&_AnytypeResolver.CallOpts, node, key)
}

// Text is a free data retrieval call binding the contract method 0x59d1d43c.
//
// Solidity: function text(bytes32 node, string key) view returns(string)
func (_AnytypeResolver *AnytypeResolverCallerSession) Text(node [32]byte, key string) (string, error) {
	return _AnytypeResolver.Contract.Text(&_AnytypeResolver.CallOpts, node, key)
}

// Zonehash is a free data retrieval call binding the contract method 0x5c98042b.
//
// Solidity: function zonehash(bytes32 node) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverCaller) Zonehash(opts *bind.CallOpts, node [32]byte) ([]byte, error) {
	var out []interface{}
	err := _AnytypeResolver.contract.Call(opts, &out, "zonehash", node)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// Zonehash is a free data retrieval call binding the contract method 0x5c98042b.
//
// Solidity: function zonehash(bytes32 node) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverSession) Zonehash(node [32]byte) ([]byte, error) {
	return _AnytypeResolver.Contract.Zonehash(&_AnytypeResolver.CallOpts, node)
}

// Zonehash is a free data retrieval call binding the contract method 0x5c98042b.
//
// Solidity: function zonehash(bytes32 node) view returns(bytes)
func (_AnytypeResolver *AnytypeResolverCallerSession) Zonehash(node [32]byte) ([]byte, error) {
	return _AnytypeResolver.Contract.Zonehash(&_AnytypeResolver.CallOpts, node)
}

// Approve is a paid mutator transaction binding the contract method 0xa4b91a01.
//
// Solidity: function approve(bytes32 node, address delegate, bool approved) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) Approve(opts *bind.TransactOpts, node [32]byte, delegate common.Address, approved bool) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "approve", node, delegate, approved)
}

// Approve is a paid mutator transaction binding the contract method 0xa4b91a01.
//
// Solidity: function approve(bytes32 node, address delegate, bool approved) returns()
func (_AnytypeResolver *AnytypeResolverSession) Approve(node [32]byte, delegate common.Address, approved bool) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.Approve(&_AnytypeResolver.TransactOpts, node, delegate, approved)
}

// Approve is a paid mutator transaction binding the contract method 0xa4b91a01.
//
// Solidity: function approve(bytes32 node, address delegate, bool approved) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) Approve(node [32]byte, delegate common.Address, approved bool) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.Approve(&_AnytypeResolver.TransactOpts, node, delegate, approved)
}

// ClearRecords is a paid mutator transaction binding the contract method 0x3603d758.
//
// Solidity: function clearRecords(bytes32 node) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) ClearRecords(opts *bind.TransactOpts, node [32]byte) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "clearRecords", node)
}

// ClearRecords is a paid mutator transaction binding the contract method 0x3603d758.
//
// Solidity: function clearRecords(bytes32 node) returns()
func (_AnytypeResolver *AnytypeResolverSession) ClearRecords(node [32]byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.ClearRecords(&_AnytypeResolver.TransactOpts, node)
}

// ClearRecords is a paid mutator transaction binding the contract method 0x3603d758.
//
// Solidity: function clearRecords(bytes32 node) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) ClearRecords(node [32]byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.ClearRecords(&_AnytypeResolver.TransactOpts, node)
}

// Multicall is a paid mutator transaction binding the contract method 0xac9650d8.
//
// Solidity: function multicall(bytes[] data) returns(bytes[] results)
func (_AnytypeResolver *AnytypeResolverTransactor) Multicall(opts *bind.TransactOpts, data [][]byte) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "multicall", data)
}

// Multicall is a paid mutator transaction binding the contract method 0xac9650d8.
//
// Solidity: function multicall(bytes[] data) returns(bytes[] results)
func (_AnytypeResolver *AnytypeResolverSession) Multicall(data [][]byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.Multicall(&_AnytypeResolver.TransactOpts, data)
}

// Multicall is a paid mutator transaction binding the contract method 0xac9650d8.
//
// Solidity: function multicall(bytes[] data) returns(bytes[] results)
func (_AnytypeResolver *AnytypeResolverTransactorSession) Multicall(data [][]byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.Multicall(&_AnytypeResolver.TransactOpts, data)
}

// MulticallWithNodeCheck is a paid mutator transaction binding the contract method 0xe32954eb.
//
// Solidity: function multicallWithNodeCheck(bytes32 nodehash, bytes[] data) returns(bytes[] results)
func (_AnytypeResolver *AnytypeResolverTransactor) MulticallWithNodeCheck(opts *bind.TransactOpts, nodehash [32]byte, data [][]byte) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "multicallWithNodeCheck", nodehash, data)
}

// MulticallWithNodeCheck is a paid mutator transaction binding the contract method 0xe32954eb.
//
// Solidity: function multicallWithNodeCheck(bytes32 nodehash, bytes[] data) returns(bytes[] results)
func (_AnytypeResolver *AnytypeResolverSession) MulticallWithNodeCheck(nodehash [32]byte, data [][]byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.MulticallWithNodeCheck(&_AnytypeResolver.TransactOpts, nodehash, data)
}

// MulticallWithNodeCheck is a paid mutator transaction binding the contract method 0xe32954eb.
//
// Solidity: function multicallWithNodeCheck(bytes32 nodehash, bytes[] data) returns(bytes[] results)
func (_AnytypeResolver *AnytypeResolverTransactorSession) MulticallWithNodeCheck(nodehash [32]byte, data [][]byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.MulticallWithNodeCheck(&_AnytypeResolver.TransactOpts, nodehash, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_AnytypeResolver *AnytypeResolverSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetApprovalForAll(&_AnytypeResolver.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetApprovalForAll(&_AnytypeResolver.TransactOpts, operator, approved)
}

// SetContenthash is a paid mutator transaction binding the contract method 0x304e6ade.
//
// Solidity: function setContenthash(bytes32 node, bytes hash) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) SetContenthash(opts *bind.TransactOpts, node [32]byte, hash []byte) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "setContenthash", node, hash)
}

// SetContenthash is a paid mutator transaction binding the contract method 0x304e6ade.
//
// Solidity: function setContenthash(bytes32 node, bytes hash) returns()
func (_AnytypeResolver *AnytypeResolverSession) SetContenthash(node [32]byte, hash []byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetContenthash(&_AnytypeResolver.TransactOpts, node, hash)
}

// SetContenthash is a paid mutator transaction binding the contract method 0x304e6ade.
//
// Solidity: function setContenthash(bytes32 node, bytes hash) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) SetContenthash(node [32]byte, hash []byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetContenthash(&_AnytypeResolver.TransactOpts, node, hash)
}

// SetDNSRecords is a paid mutator transaction binding the contract method 0x0af179d7.
//
// Solidity: function setDNSRecords(bytes32 node, bytes data) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) SetDNSRecords(opts *bind.TransactOpts, node [32]byte, data []byte) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "setDNSRecords", node, data)
}

// SetDNSRecords is a paid mutator transaction binding the contract method 0x0af179d7.
//
// Solidity: function setDNSRecords(bytes32 node, bytes data) returns()
func (_AnytypeResolver *AnytypeResolverSession) SetDNSRecords(node [32]byte, data []byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetDNSRecords(&_AnytypeResolver.TransactOpts, node, data)
}

// SetDNSRecords is a paid mutator transaction binding the contract method 0x0af179d7.
//
// Solidity: function setDNSRecords(bytes32 node, bytes data) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) SetDNSRecords(node [32]byte, data []byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetDNSRecords(&_AnytypeResolver.TransactOpts, node, data)
}

// SetName is a paid mutator transaction binding the contract method 0x77372213.
//
// Solidity: function setName(bytes32 node, string newName) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) SetName(opts *bind.TransactOpts, node [32]byte, newName string) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "setName", node, newName)
}

// SetName is a paid mutator transaction binding the contract method 0x77372213.
//
// Solidity: function setName(bytes32 node, string newName) returns()
func (_AnytypeResolver *AnytypeResolverSession) SetName(node [32]byte, newName string) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetName(&_AnytypeResolver.TransactOpts, node, newName)
}

// SetName is a paid mutator transaction binding the contract method 0x77372213.
//
// Solidity: function setName(bytes32 node, string newName) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) SetName(node [32]byte, newName string) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetName(&_AnytypeResolver.TransactOpts, node, newName)
}

// SetPubkey is a paid mutator transaction binding the contract method 0x29cd62ea.
//
// Solidity: function setPubkey(bytes32 node, bytes32 x, bytes32 y) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) SetPubkey(opts *bind.TransactOpts, node [32]byte, x [32]byte, y [32]byte) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "setPubkey", node, x, y)
}

// SetPubkey is a paid mutator transaction binding the contract method 0x29cd62ea.
//
// Solidity: function setPubkey(bytes32 node, bytes32 x, bytes32 y) returns()
func (_AnytypeResolver *AnytypeResolverSession) SetPubkey(node [32]byte, x [32]byte, y [32]byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetPubkey(&_AnytypeResolver.TransactOpts, node, x, y)
}

// SetPubkey is a paid mutator transaction binding the contract method 0x29cd62ea.
//
// Solidity: function setPubkey(bytes32 node, bytes32 x, bytes32 y) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) SetPubkey(node [32]byte, x [32]byte, y [32]byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetPubkey(&_AnytypeResolver.TransactOpts, node, x, y)
}

// SetSpaceId is a paid mutator transaction binding the contract method 0xf49c1a7b.
//
// Solidity: function setSpaceId(bytes32 node, bytes spaceid) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) SetSpaceId(opts *bind.TransactOpts, node [32]byte, spaceid []byte) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "setSpaceId", node, spaceid)
}

// SetSpaceId is a paid mutator transaction binding the contract method 0xf49c1a7b.
//
// Solidity: function setSpaceId(bytes32 node, bytes spaceid) returns()
func (_AnytypeResolver *AnytypeResolverSession) SetSpaceId(node [32]byte, spaceid []byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetSpaceId(&_AnytypeResolver.TransactOpts, node, spaceid)
}

// SetSpaceId is a paid mutator transaction binding the contract method 0xf49c1a7b.
//
// Solidity: function setSpaceId(bytes32 node, bytes spaceid) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) SetSpaceId(node [32]byte, spaceid []byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetSpaceId(&_AnytypeResolver.TransactOpts, node, spaceid)
}

// SetText is a paid mutator transaction binding the contract method 0x10f13a8c.
//
// Solidity: function setText(bytes32 node, string key, string value) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) SetText(opts *bind.TransactOpts, node [32]byte, key string, value string) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "setText", node, key, value)
}

// SetText is a paid mutator transaction binding the contract method 0x10f13a8c.
//
// Solidity: function setText(bytes32 node, string key, string value) returns()
func (_AnytypeResolver *AnytypeResolverSession) SetText(node [32]byte, key string, value string) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetText(&_AnytypeResolver.TransactOpts, node, key, value)
}

// SetText is a paid mutator transaction binding the contract method 0x10f13a8c.
//
// Solidity: function setText(bytes32 node, string key, string value) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) SetText(node [32]byte, key string, value string) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetText(&_AnytypeResolver.TransactOpts, node, key, value)
}

// SetZonehash is a paid mutator transaction binding the contract method 0xce3decdc.
//
// Solidity: function setZonehash(bytes32 node, bytes hash) returns()
func (_AnytypeResolver *AnytypeResolverTransactor) SetZonehash(opts *bind.TransactOpts, node [32]byte, hash []byte) (*types.Transaction, error) {
	return _AnytypeResolver.contract.Transact(opts, "setZonehash", node, hash)
}

// SetZonehash is a paid mutator transaction binding the contract method 0xce3decdc.
//
// Solidity: function setZonehash(bytes32 node, bytes hash) returns()
func (_AnytypeResolver *AnytypeResolverSession) SetZonehash(node [32]byte, hash []byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetZonehash(&_AnytypeResolver.TransactOpts, node, hash)
}

// SetZonehash is a paid mutator transaction binding the contract method 0xce3decdc.
//
// Solidity: function setZonehash(bytes32 node, bytes hash) returns()
func (_AnytypeResolver *AnytypeResolverTransactorSession) SetZonehash(node [32]byte, hash []byte) (*types.Transaction, error) {
	return _AnytypeResolver.Contract.SetZonehash(&_AnytypeResolver.TransactOpts, node, hash)
}

// AnytypeResolverApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the AnytypeResolver contract.
type AnytypeResolverApprovalForAllIterator struct {
	Event *AnytypeResolverApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverApprovalForAll represents a ApprovalForAll event raised by the AnytypeResolver contract.
type AnytypeResolverApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*AnytypeResolverApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverApprovalForAllIterator{contract: _AnytypeResolver.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *AnytypeResolverApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverApprovalForAll)
				if err := _AnytypeResolver.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseApprovalForAll(log types.Log) (*AnytypeResolverApprovalForAll, error) {
	event := new(AnytypeResolverApprovalForAll)
	if err := _AnytypeResolver.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverApprovedIterator is returned from FilterApproved and is used to iterate over the raw logs and unpacked data for Approved events raised by the AnytypeResolver contract.
type AnytypeResolverApprovedIterator struct {
	Event *AnytypeResolverApproved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverApprovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverApproved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverApproved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverApprovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverApprovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverApproved represents a Approved event raised by the AnytypeResolver contract.
type AnytypeResolverApproved struct {
	Owner    common.Address
	Node     [32]byte
	Delegate common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproved is a free log retrieval operation binding the contract event 0xf0ddb3b04746704017f9aa8bd728fcc2c1d11675041205350018915f5e4750a0.
//
// Solidity: event Approved(address owner, bytes32 indexed node, address indexed delegate, bool indexed approved)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterApproved(opts *bind.FilterOpts, node [][32]byte, delegate []common.Address, approved []bool) (*AnytypeResolverApprovedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}
	var delegateRule []interface{}
	for _, delegateItem := range delegate {
		delegateRule = append(delegateRule, delegateItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "Approved", nodeRule, delegateRule, approvedRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverApprovedIterator{contract: _AnytypeResolver.contract, event: "Approved", logs: logs, sub: sub}, nil
}

// WatchApproved is a free log subscription operation binding the contract event 0xf0ddb3b04746704017f9aa8bd728fcc2c1d11675041205350018915f5e4750a0.
//
// Solidity: event Approved(address owner, bytes32 indexed node, address indexed delegate, bool indexed approved)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchApproved(opts *bind.WatchOpts, sink chan<- *AnytypeResolverApproved, node [][32]byte, delegate []common.Address, approved []bool) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}
	var delegateRule []interface{}
	for _, delegateItem := range delegate {
		delegateRule = append(delegateRule, delegateItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "Approved", nodeRule, delegateRule, approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverApproved)
				if err := _AnytypeResolver.contract.UnpackLog(event, "Approved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproved is a log parse operation binding the contract event 0xf0ddb3b04746704017f9aa8bd728fcc2c1d11675041205350018915f5e4750a0.
//
// Solidity: event Approved(address owner, bytes32 indexed node, address indexed delegate, bool indexed approved)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseApproved(log types.Log) (*AnytypeResolverApproved, error) {
	event := new(AnytypeResolverApproved)
	if err := _AnytypeResolver.contract.UnpackLog(event, "Approved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverContenthashChangedIterator is returned from FilterContenthashChanged and is used to iterate over the raw logs and unpacked data for ContenthashChanged events raised by the AnytypeResolver contract.
type AnytypeResolverContenthashChangedIterator struct {
	Event *AnytypeResolverContenthashChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverContenthashChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverContenthashChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverContenthashChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverContenthashChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverContenthashChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverContenthashChanged represents a ContenthashChanged event raised by the AnytypeResolver contract.
type AnytypeResolverContenthashChanged struct {
	Node [32]byte
	Hash []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterContenthashChanged is a free log retrieval operation binding the contract event 0xe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d7578.
//
// Solidity: event ContenthashChanged(bytes32 indexed node, bytes hash)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterContenthashChanged(opts *bind.FilterOpts, node [][32]byte) (*AnytypeResolverContenthashChangedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "ContenthashChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverContenthashChangedIterator{contract: _AnytypeResolver.contract, event: "ContenthashChanged", logs: logs, sub: sub}, nil
}

// WatchContenthashChanged is a free log subscription operation binding the contract event 0xe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d7578.
//
// Solidity: event ContenthashChanged(bytes32 indexed node, bytes hash)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchContenthashChanged(opts *bind.WatchOpts, sink chan<- *AnytypeResolverContenthashChanged, node [][32]byte) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "ContenthashChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverContenthashChanged)
				if err := _AnytypeResolver.contract.UnpackLog(event, "ContenthashChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseContenthashChanged is a log parse operation binding the contract event 0xe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d7578.
//
// Solidity: event ContenthashChanged(bytes32 indexed node, bytes hash)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseContenthashChanged(log types.Log) (*AnytypeResolverContenthashChanged, error) {
	event := new(AnytypeResolverContenthashChanged)
	if err := _AnytypeResolver.contract.UnpackLog(event, "ContenthashChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverDNSRecordChangedIterator is returned from FilterDNSRecordChanged and is used to iterate over the raw logs and unpacked data for DNSRecordChanged events raised by the AnytypeResolver contract.
type AnytypeResolverDNSRecordChangedIterator struct {
	Event *AnytypeResolverDNSRecordChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverDNSRecordChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverDNSRecordChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverDNSRecordChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverDNSRecordChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverDNSRecordChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverDNSRecordChanged represents a DNSRecordChanged event raised by the AnytypeResolver contract.
type AnytypeResolverDNSRecordChanged struct {
	Node     [32]byte
	Name     []byte
	Resource uint16
	Record   []byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDNSRecordChanged is a free log retrieval operation binding the contract event 0x52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b.
//
// Solidity: event DNSRecordChanged(bytes32 indexed node, bytes name, uint16 resource, bytes record)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterDNSRecordChanged(opts *bind.FilterOpts, node [][32]byte) (*AnytypeResolverDNSRecordChangedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "DNSRecordChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverDNSRecordChangedIterator{contract: _AnytypeResolver.contract, event: "DNSRecordChanged", logs: logs, sub: sub}, nil
}

// WatchDNSRecordChanged is a free log subscription operation binding the contract event 0x52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b.
//
// Solidity: event DNSRecordChanged(bytes32 indexed node, bytes name, uint16 resource, bytes record)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchDNSRecordChanged(opts *bind.WatchOpts, sink chan<- *AnytypeResolverDNSRecordChanged, node [][32]byte) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "DNSRecordChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverDNSRecordChanged)
				if err := _AnytypeResolver.contract.UnpackLog(event, "DNSRecordChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDNSRecordChanged is a log parse operation binding the contract event 0x52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b.
//
// Solidity: event DNSRecordChanged(bytes32 indexed node, bytes name, uint16 resource, bytes record)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseDNSRecordChanged(log types.Log) (*AnytypeResolverDNSRecordChanged, error) {
	event := new(AnytypeResolverDNSRecordChanged)
	if err := _AnytypeResolver.contract.UnpackLog(event, "DNSRecordChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverDNSRecordDeletedIterator is returned from FilterDNSRecordDeleted and is used to iterate over the raw logs and unpacked data for DNSRecordDeleted events raised by the AnytypeResolver contract.
type AnytypeResolverDNSRecordDeletedIterator struct {
	Event *AnytypeResolverDNSRecordDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverDNSRecordDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverDNSRecordDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverDNSRecordDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverDNSRecordDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverDNSRecordDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverDNSRecordDeleted represents a DNSRecordDeleted event raised by the AnytypeResolver contract.
type AnytypeResolverDNSRecordDeleted struct {
	Node     [32]byte
	Name     []byte
	Resource uint16
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDNSRecordDeleted is a free log retrieval operation binding the contract event 0x03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a1207.
//
// Solidity: event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterDNSRecordDeleted(opts *bind.FilterOpts, node [][32]byte) (*AnytypeResolverDNSRecordDeletedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "DNSRecordDeleted", nodeRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverDNSRecordDeletedIterator{contract: _AnytypeResolver.contract, event: "DNSRecordDeleted", logs: logs, sub: sub}, nil
}

// WatchDNSRecordDeleted is a free log subscription operation binding the contract event 0x03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a1207.
//
// Solidity: event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchDNSRecordDeleted(opts *bind.WatchOpts, sink chan<- *AnytypeResolverDNSRecordDeleted, node [][32]byte) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "DNSRecordDeleted", nodeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverDNSRecordDeleted)
				if err := _AnytypeResolver.contract.UnpackLog(event, "DNSRecordDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDNSRecordDeleted is a log parse operation binding the contract event 0x03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a1207.
//
// Solidity: event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseDNSRecordDeleted(log types.Log) (*AnytypeResolverDNSRecordDeleted, error) {
	event := new(AnytypeResolverDNSRecordDeleted)
	if err := _AnytypeResolver.contract.UnpackLog(event, "DNSRecordDeleted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverDNSZonehashChangedIterator is returned from FilterDNSZonehashChanged and is used to iterate over the raw logs and unpacked data for DNSZonehashChanged events raised by the AnytypeResolver contract.
type AnytypeResolverDNSZonehashChangedIterator struct {
	Event *AnytypeResolverDNSZonehashChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverDNSZonehashChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverDNSZonehashChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverDNSZonehashChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverDNSZonehashChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverDNSZonehashChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverDNSZonehashChanged represents a DNSZonehashChanged event raised by the AnytypeResolver contract.
type AnytypeResolverDNSZonehashChanged struct {
	Node         [32]byte
	Lastzonehash []byte
	Zonehash     []byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterDNSZonehashChanged is a free log retrieval operation binding the contract event 0x8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f85.
//
// Solidity: event DNSZonehashChanged(bytes32 indexed node, bytes lastzonehash, bytes zonehash)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterDNSZonehashChanged(opts *bind.FilterOpts, node [][32]byte) (*AnytypeResolverDNSZonehashChangedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "DNSZonehashChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverDNSZonehashChangedIterator{contract: _AnytypeResolver.contract, event: "DNSZonehashChanged", logs: logs, sub: sub}, nil
}

// WatchDNSZonehashChanged is a free log subscription operation binding the contract event 0x8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f85.
//
// Solidity: event DNSZonehashChanged(bytes32 indexed node, bytes lastzonehash, bytes zonehash)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchDNSZonehashChanged(opts *bind.WatchOpts, sink chan<- *AnytypeResolverDNSZonehashChanged, node [][32]byte) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "DNSZonehashChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverDNSZonehashChanged)
				if err := _AnytypeResolver.contract.UnpackLog(event, "DNSZonehashChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDNSZonehashChanged is a log parse operation binding the contract event 0x8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f85.
//
// Solidity: event DNSZonehashChanged(bytes32 indexed node, bytes lastzonehash, bytes zonehash)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseDNSZonehashChanged(log types.Log) (*AnytypeResolverDNSZonehashChanged, error) {
	event := new(AnytypeResolverDNSZonehashChanged)
	if err := _AnytypeResolver.contract.UnpackLog(event, "DNSZonehashChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverNameChangedIterator is returned from FilterNameChanged and is used to iterate over the raw logs and unpacked data for NameChanged events raised by the AnytypeResolver contract.
type AnytypeResolverNameChangedIterator struct {
	Event *AnytypeResolverNameChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverNameChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverNameChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverNameChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverNameChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverNameChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverNameChanged represents a NameChanged event raised by the AnytypeResolver contract.
type AnytypeResolverNameChanged struct {
	Node [32]byte
	Name string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterNameChanged is a free log retrieval operation binding the contract event 0xb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f7.
//
// Solidity: event NameChanged(bytes32 indexed node, string name)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterNameChanged(opts *bind.FilterOpts, node [][32]byte) (*AnytypeResolverNameChangedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "NameChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverNameChangedIterator{contract: _AnytypeResolver.contract, event: "NameChanged", logs: logs, sub: sub}, nil
}

// WatchNameChanged is a free log subscription operation binding the contract event 0xb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f7.
//
// Solidity: event NameChanged(bytes32 indexed node, string name)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchNameChanged(opts *bind.WatchOpts, sink chan<- *AnytypeResolverNameChanged, node [][32]byte) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "NameChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverNameChanged)
				if err := _AnytypeResolver.contract.UnpackLog(event, "NameChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNameChanged is a log parse operation binding the contract event 0xb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f7.
//
// Solidity: event NameChanged(bytes32 indexed node, string name)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseNameChanged(log types.Log) (*AnytypeResolverNameChanged, error) {
	event := new(AnytypeResolverNameChanged)
	if err := _AnytypeResolver.contract.UnpackLog(event, "NameChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverPubkeyChangedIterator is returned from FilterPubkeyChanged and is used to iterate over the raw logs and unpacked data for PubkeyChanged events raised by the AnytypeResolver contract.
type AnytypeResolverPubkeyChangedIterator struct {
	Event *AnytypeResolverPubkeyChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverPubkeyChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverPubkeyChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverPubkeyChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverPubkeyChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverPubkeyChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverPubkeyChanged represents a PubkeyChanged event raised by the AnytypeResolver contract.
type AnytypeResolverPubkeyChanged struct {
	Node [32]byte
	X    [32]byte
	Y    [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterPubkeyChanged is a free log retrieval operation binding the contract event 0x1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e46.
//
// Solidity: event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterPubkeyChanged(opts *bind.FilterOpts, node [][32]byte) (*AnytypeResolverPubkeyChangedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "PubkeyChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverPubkeyChangedIterator{contract: _AnytypeResolver.contract, event: "PubkeyChanged", logs: logs, sub: sub}, nil
}

// WatchPubkeyChanged is a free log subscription operation binding the contract event 0x1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e46.
//
// Solidity: event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchPubkeyChanged(opts *bind.WatchOpts, sink chan<- *AnytypeResolverPubkeyChanged, node [][32]byte) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "PubkeyChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverPubkeyChanged)
				if err := _AnytypeResolver.contract.UnpackLog(event, "PubkeyChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePubkeyChanged is a log parse operation binding the contract event 0x1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e46.
//
// Solidity: event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y)
func (_AnytypeResolver *AnytypeResolverFilterer) ParsePubkeyChanged(log types.Log) (*AnytypeResolverPubkeyChanged, error) {
	event := new(AnytypeResolverPubkeyChanged)
	if err := _AnytypeResolver.contract.UnpackLog(event, "PubkeyChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverSpaceIDChangedIterator is returned from FilterSpaceIDChanged and is used to iterate over the raw logs and unpacked data for SpaceIDChanged events raised by the AnytypeResolver contract.
type AnytypeResolverSpaceIDChangedIterator struct {
	Event *AnytypeResolverSpaceIDChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverSpaceIDChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverSpaceIDChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverSpaceIDChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverSpaceIDChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverSpaceIDChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverSpaceIDChanged represents a SpaceIDChanged event raised by the AnytypeResolver contract.
type AnytypeResolverSpaceIDChanged struct {
	Node    [32]byte
	SpaceId []byte
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterSpaceIDChanged is a free log retrieval operation binding the contract event 0xd0f766f33d7be4ce1dbcfb11f7fbe0cb18b74331b99a4a7c1565c95471346e38.
//
// Solidity: event SpaceIDChanged(bytes32 indexed node, bytes spaceId)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterSpaceIDChanged(opts *bind.FilterOpts, node [][32]byte) (*AnytypeResolverSpaceIDChangedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "SpaceIDChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverSpaceIDChangedIterator{contract: _AnytypeResolver.contract, event: "SpaceIDChanged", logs: logs, sub: sub}, nil
}

// WatchSpaceIDChanged is a free log subscription operation binding the contract event 0xd0f766f33d7be4ce1dbcfb11f7fbe0cb18b74331b99a4a7c1565c95471346e38.
//
// Solidity: event SpaceIDChanged(bytes32 indexed node, bytes spaceId)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchSpaceIDChanged(opts *bind.WatchOpts, sink chan<- *AnytypeResolverSpaceIDChanged, node [][32]byte) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "SpaceIDChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverSpaceIDChanged)
				if err := _AnytypeResolver.contract.UnpackLog(event, "SpaceIDChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSpaceIDChanged is a log parse operation binding the contract event 0xd0f766f33d7be4ce1dbcfb11f7fbe0cb18b74331b99a4a7c1565c95471346e38.
//
// Solidity: event SpaceIDChanged(bytes32 indexed node, bytes spaceId)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseSpaceIDChanged(log types.Log) (*AnytypeResolverSpaceIDChanged, error) {
	event := new(AnytypeResolverSpaceIDChanged)
	if err := _AnytypeResolver.contract.UnpackLog(event, "SpaceIDChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverTextChangedIterator is returned from FilterTextChanged and is used to iterate over the raw logs and unpacked data for TextChanged events raised by the AnytypeResolver contract.
type AnytypeResolverTextChangedIterator struct {
	Event *AnytypeResolverTextChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverTextChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverTextChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverTextChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverTextChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverTextChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverTextChanged represents a TextChanged event raised by the AnytypeResolver contract.
type AnytypeResolverTextChanged struct {
	Node       [32]byte
	IndexedKey common.Hash
	Key        string
	Value      string
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterTextChanged is a free log retrieval operation binding the contract event 0x448bc014f1536726cf8d54ff3d6481ed3cbc683c2591ca204274009afa09b1a1.
//
// Solidity: event TextChanged(bytes32 indexed node, string indexed indexedKey, string key, string value)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterTextChanged(opts *bind.FilterOpts, node [][32]byte, indexedKey []string) (*AnytypeResolverTextChangedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}
	var indexedKeyRule []interface{}
	for _, indexedKeyItem := range indexedKey {
		indexedKeyRule = append(indexedKeyRule, indexedKeyItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "TextChanged", nodeRule, indexedKeyRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverTextChangedIterator{contract: _AnytypeResolver.contract, event: "TextChanged", logs: logs, sub: sub}, nil
}

// WatchTextChanged is a free log subscription operation binding the contract event 0x448bc014f1536726cf8d54ff3d6481ed3cbc683c2591ca204274009afa09b1a1.
//
// Solidity: event TextChanged(bytes32 indexed node, string indexed indexedKey, string key, string value)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchTextChanged(opts *bind.WatchOpts, sink chan<- *AnytypeResolverTextChanged, node [][32]byte, indexedKey []string) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}
	var indexedKeyRule []interface{}
	for _, indexedKeyItem := range indexedKey {
		indexedKeyRule = append(indexedKeyRule, indexedKeyItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "TextChanged", nodeRule, indexedKeyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverTextChanged)
				if err := _AnytypeResolver.contract.UnpackLog(event, "TextChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTextChanged is a log parse operation binding the contract event 0x448bc014f1536726cf8d54ff3d6481ed3cbc683c2591ca204274009afa09b1a1.
//
// Solidity: event TextChanged(bytes32 indexed node, string indexed indexedKey, string key, string value)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseTextChanged(log types.Log) (*AnytypeResolverTextChanged, error) {
	event := new(AnytypeResolverTextChanged)
	if err := _AnytypeResolver.contract.UnpackLog(event, "TextChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnytypeResolverVersionChangedIterator is returned from FilterVersionChanged and is used to iterate over the raw logs and unpacked data for VersionChanged events raised by the AnytypeResolver contract.
type AnytypeResolverVersionChangedIterator struct {
	Event *AnytypeResolverVersionChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnytypeResolverVersionChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnytypeResolverVersionChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnytypeResolverVersionChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnytypeResolverVersionChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnytypeResolverVersionChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnytypeResolverVersionChanged represents a VersionChanged event raised by the AnytypeResolver contract.
type AnytypeResolverVersionChanged struct {
	Node       [32]byte
	NewVersion uint64
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterVersionChanged is a free log retrieval operation binding the contract event 0xc6621ccb8f3f5a04bb6502154b2caf6adf5983fe76dfef1cfc9c42e3579db444.
//
// Solidity: event VersionChanged(bytes32 indexed node, uint64 newVersion)
func (_AnytypeResolver *AnytypeResolverFilterer) FilterVersionChanged(opts *bind.FilterOpts, node [][32]byte) (*AnytypeResolverVersionChangedIterator, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.FilterLogs(opts, "VersionChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return &AnytypeResolverVersionChangedIterator{contract: _AnytypeResolver.contract, event: "VersionChanged", logs: logs, sub: sub}, nil
}

// WatchVersionChanged is a free log subscription operation binding the contract event 0xc6621ccb8f3f5a04bb6502154b2caf6adf5983fe76dfef1cfc9c42e3579db444.
//
// Solidity: event VersionChanged(bytes32 indexed node, uint64 newVersion)
func (_AnytypeResolver *AnytypeResolverFilterer) WatchVersionChanged(opts *bind.WatchOpts, sink chan<- *AnytypeResolverVersionChanged, node [][32]byte) (event.Subscription, error) {

	var nodeRule []interface{}
	for _, nodeItem := range node {
		nodeRule = append(nodeRule, nodeItem)
	}

	logs, sub, err := _AnytypeResolver.contract.WatchLogs(opts, "VersionChanged", nodeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnytypeResolverVersionChanged)
				if err := _AnytypeResolver.contract.UnpackLog(event, "VersionChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVersionChanged is a log parse operation binding the contract event 0xc6621ccb8f3f5a04bb6502154b2caf6adf5983fe76dfef1cfc9c42e3579db444.
//
// Solidity: event VersionChanged(bytes32 indexed node, uint64 newVersion)
func (_AnytypeResolver *AnytypeResolverFilterer) ParseVersionChanged(log types.Log) (*AnytypeResolverVersionChanged, error) {
	event := new(AnytypeResolverVersionChanged)
	if err := _AnytypeResolver.contract.UnpackLog(event, "VersionChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
